TASK: Implement systematic prompt factory improvements based on detailed feedback analysis
CONTEXT: We have identified critical mismatches between prompt definitions and actual outputs across our ScriptTok template system. Need to fix prompts, add validation, and ensure compliance.
PHASE 1: CRITICAL TEMPLATE FIXES
1. Fix Beauty Short Video Template (server/services/promptFactory.ts)
   - Current generateBeautyShortVideo produces 370-word routine instead of 70-140 word script
   - Replace with same structure as generateFitnessShortVideo and generateTechShortVideo:
     * Hook (attention-grabbing opening)
     * 2-3 key features with benefits
     * Quick problem/solution
     * Who it's for
     * Motivational CTA
   - Total: 70-140 words for 30-60 second delivery
2. Add Universal Audit Footer to ALL prompts (server/services/promptFactory.ts)
   - Append to every template's basePrompt/userPrompt BEFORE returning:
   
   "OUTPUT VALIDATION CHECKLIST:
   Before returning your response, verify:
   ✓ All required sections present and properly formatted
   ✓ Word count within specified limits (count total words)
   ✓ Emojis removed (unless template explicitly allows them)
   ✓ No bracketed notes like [Note:] or [Performance Notes:]
   ✓ Required hashtags included (count them: must have exact number specified)
   ✓ Compliance disclosures present (#ad, affiliate statement, etc.)
   
   If ANY check fails, revise your output before returning. Do not explain - just output corrected content."
PHASE 2: TEMPLATE-SPECIFIC PROMPT ENHANCEMENTS
3. Influencer Caption (generateUniversalInfluencerCaption):
   - Add: "Output exactly 4 paragraphs + 15-20 hashtags ending with #ad"
   - Add: "No emojis anywhere in caption"
   - Enforce disclosure requirement
4. Affiliate Email (generateUniversalAffiliateEmail):
   - Add: "HARD CAP: Maximum 150 words total. Count words before returning."
   - Add: "Avoid ALL metaphors, similes, and figurative language - use only direct statements"
5. SEO Blog (generateUniversalSEOBlog):
   - Add: "Minimum 1,050 words (do not return if under 1,000)"
   - Add: "Use H2 and H3 markdown headings (## and ###)"
   - Add: "Include 3-question FAQ section before conclusion"
   - Add: "End with bullet-point summary + CTA + affiliate disclosure"
6. Routine/Kit (generateUniversalRoutine):
   - Add: "Include 3-bullet Troubleshooting section"
   - Add: "Add 2 brief variants for different skin types/needs"
7. Product Comparison (generateUniversalComparison):
   - Add to Brand Reputation section: "Cite one credible signal (award, years in market, category expertise)"
8. Universal Short Video Script (generateUniversalShortVideoScript):
   - Add: "Output exactly 5 paragraphs with one concise sentence each"
   - Keep 70-140 word limit strict
9. Viral Hooks (generateViralHooks):
   - Add: "Output ONLY a numbered list 1-10. Absolutely no commentary or explanations after."
   - Add self-check: "Verify each hook is 3-8 words before returning"
10. Viral Short Script (generateViralShortScript):
    - Add: "No emojis. No bracketed performance notes. Output only the 4 labeled sections."
11. Viral Storytime (generateViralStorytime):
    - Add: "Format as ONE SINGLE PARAGRAPH. 90-130 words only. No emojis."
12. Viral Duet/Reaction (generateViralDuetReaction):
    - Add: "Output exactly 6 labeled lines only. No stage directions, no emojis, no performance notes."
13. Viral Listicle (generateViralListicle):
    - Add: "No commentary after list. Verify: Title ≤6 words, Explanation ≤14 words, Example ≤10 words"
14. Viral Caption + Hashtags (generateViralCaptionHashtags):
    - Add: "CRITICAL: Validate both hashtag blocks contain real hashtags starting with #"
    - Add: "If hashtags missing or malformed, regenerate before returning"
    - Add: "No notes or commentary after hashtags"
PHASE 3: POST-PROCESSING VALIDATION
15. Create new validation service (server/services/contentValidator.ts):
import { TemplateType } from '@shared/constants';
interface ValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  fixes: string[];
}
interface TemplateRules {
  minWords?: number;
  maxWords?: number;
  requiredSections?: string[];
  allowEmojis?: boolean;
  requireHashtags?: boolean;
  hashtagCount?: { min: number; max: number };
  requireDisclosure?: boolean;
  banBracketedNotes?: boolean;
}
const TEMPLATE_VALIDATION_RULES: Record<TemplateType, TemplateRules> = {
  'influencer_caption': {
    maxWords: 200,
    allowEmojis: false,
    requireHashtags: true,
    hashtagCount: { min: 15, max: 20 },
    requireDisclosure: true,
    banBracketedNotes: true
  },
  'affiliate_email': {
    maxWords: 150,
    allowEmojis: false,
    banBracketedNotes: true,
    requireDisclosure: true
  },
  'seo_blog': {
    minWords: 1000,
    allowEmojis: false,
    requiredSections: ['H2', 'FAQ', 'conclusion'],
    requireDisclosure: true
  },
  // ... add all other templates
};
export function validateContent(
  content: string,
  templateType: TemplateType
): ValidationResult {
  const rules = TEMPLATE_VALIDATION_RULES[templateType];
  const errors: string[] = [];
  const warnings: string[] = [];
  const fixes: string[] = [];
  // Word count validation
  const wordCount = content.trim().split(/\s+/).length;
  if (rules.minWords && wordCount < rules.minWords) {
    errors.push(`Content too short: ${wordCount} words (minimum ${rules.minWords})`);
  }
  if (rules.maxWords && wordCount > rules.maxWords) {
    errors.push(`Content too long: ${wordCount} words (maximum ${rules.maxWords})`);
  }
  // Emoji validation
  if (!rules.allowEmojis) {
    const emojiRegex = /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu;
    if (emojiRegex.test(content)) {
      errors.push('Emojis found but not allowed for this template');
      fixes.push('Remove all emojis from content');
    }
  }
  // Bracketed notes validation
  if (rules.banBracketedNotes) {
    const bracketedNoteRegex = /\[Note:|\[Performance Notes:|\[.*?:\]/gi;
    if (bracketedNoteRegex.test(content)) {
      errors.push('Bracketed notes found in output');
      fixes.push('Remove all bracketed notes like [Note:] or [Performance Notes:]');
    }
  }
  // Hashtag validation
  if (rules.requireHashtags) {
    const hashtags = content.match(/#\w+/g) || [];
    const hashtagCount = hashtags.length;
    
    if (rules.hashtagCount) {
      if (hashtagCount < rules.hashtagCount.min) {
        errors.push(`Not enough hashtags: ${hashtagCount} (minimum ${rules.hashtagCount.min})`);
      }
      if (hashtagCount > rules.hashtagCount.max) {
        warnings.push(`Too many hashtags: ${hashtagCount} (maximum ${rules.hashtagCount.max})`);
      }
    }
  }
  // Disclosure validation
  if (rules.requireDisclosure) {
    const hasAdDisclosure = /#ad/i.test(content);
    const hasAffiliateDisclosure = /affiliate|amazon associate/i.test(content);
    
    if (!hasAdDisclosure && !hasAffiliateDisclosure) {
      errors.push('Missing required disclosure (#ad or affiliate statement)');
      fixes.push('Add #ad or affiliate disclosure to content');
    }
  }
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    fixes
  };
}
16. Integrate validator into content generator (server/services/contentGenerator.ts):
   - Import validateContent function
   - After AI generation, before returning:
     * Run validation
     * Log validation results
     * If errors found, log them but don't auto-regenerate (expensive)
     * Return validation metadata with content
17. Add validation endpoint (server/routes.ts):
   - POST /api/validate-content
   - Returns validation results for debugging
   - Allows manual validation trigger
PHASE 4: TESTING & LOGGING
18. Add validation logging to database (server/database/validationLogger.ts):
   - Track validation failures by template
   - Identify which templates fail most often
   - Use data to refine prompts iteratively
19. Create validation dashboard component (client/src/components/ValidationDashboard.tsx):
   - Show validation pass/fail rates by template
   - Display common errors
   - Help identify systematic issues
IMPLEMENTATION NOTES:
- Make all changes backward compatible
- Don't break existing content generation
- Log extensively for debugging
- Add feature flag for validation (can disable if issues arise)
- Test each template type individually after changes
PRIORITY ORDER:
1. Fix beauty short video template (critical structural issue)
2. Add audit footer to all prompts (catches most issues)
3. Implement post-processor validation (safety net)
4. Add template-specific enhancements (quality improvements)
5. Build validation dashboard (monitoring)
SUCCESS CRITERIA:
- All templates output within word count limits
- Required hashtags/disclosures always present
- No emojis in templates that ban them
- No bracketed notes in any output
- Validation pass rate >90% across all templates