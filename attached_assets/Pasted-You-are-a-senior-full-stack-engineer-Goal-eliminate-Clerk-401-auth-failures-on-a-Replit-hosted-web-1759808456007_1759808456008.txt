You are a senior full-stack engineer. Goal: eliminate Clerk 401 auth failures on a Replit-hosted web app (Vite/React frontend + Node/Express backend; adjust if the repo differs). Move with discipline: detect stack, audit config, fix Clerk wiring, prove end-to-end sign-in with Email/Password and Google OAuth, and produce a testable checklist + logs. If and only if Clerk remains broken after all fixes, output a clean, reversible patch to switch to Supabase Auth as a Plan B (do not execute Plan B unless explicitly instructed by ENABLE_PLAN_B=true in env).

ACCEPTANCE CRITERIA
	1.	Visiting the live Replit URL (not IDE iframe) shows working auth:
	•	Email/password signup/sign-in works.
	•	Google OAuth works (redirects complete, user session present).
	2.	Protected backend route returns 200 with verified user; returns 401 when unauthenticated.
	3.	No 401s from Clerk SDK/API calls in browser console or server logs.
	4.	A /health/auth and /health/server endpoint report green status.
	5.	Deliverables committed to repo (see “Deliverables” section).

CONSTRAINTS
	•	Do not leak secrets to logs. Use env placeholders in code.
	•	Use all test or all live Clerk credentials consistently; no mixing.
	•	Test in a new browser tab to avoid iframe/3rd-party cookie issues.
	•	Keep changes minimal, well-scoped, and reversible.

INPUTS (SET/VERIFY IN REPLIT SECRETS)
	•	CLERK_PUBLISHABLE_KEY=pk_*
	•	CLERK_SECRET_KEY=sk_*
	•	NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_* (duplicate for frontend frameworks that read NEXT_PUBLIC)
	•	NEXT_PUBLIC_CLERK_FRONTEND_API=https://<your-subdomain>.clerk.accounts.dev
	•	APP_BASE_URL=https://<your-app>.replit.dev
	•	ENABLE_PLAN_B=false (set true only if asked)

TASKS

1) Detect stack & map files
	•	Identify frontend (likely vite + react-ts). Locate entry (e.g., src/main.tsx) and router.
	•	Identify backend (likely server/index.ts or server.ts/app.ts). Confirm port and start command.
	•	Print a short map of auth-related files.

2) Frontend audit & fix (Clerk)
	•	Ensure app is wrapped with ClerkProvider.
	•	Example:

import { ClerkProvider } from '@clerk/clerk-react';
const pk = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY || import.meta.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY;
const frontendApi = import.meta.env.VITE_CLERK_FRONTEND_API || import.meta.env.NEXT_PUBLIC_CLERK_FRONTEND_API;
<ClerkProvider publishableKey={pk} frontendApi={frontendApi}>
  <App/>
</ClerkProvider>


	•	Add auth UI routes/components if missing:
	•	/sign-in, /sign-up using <SignIn/>, <SignUp/>.
	•	User button in header: <UserButton/>.
	•	Add a small auth state probe:

import { useUser } from '@clerk/clerk-react';
// Render user.id/email when signed in; "signed out" otherwise.


	•	Guard at least one protected page with SignedIn / SignedOut or route guard.

3) Backend audit & fix (Clerk verification)
	•	Install server SDK if missing: @clerk/clerk-sdk-node (or @clerk/express).
	•	Add middleware to verify tokens on protected routes:

import { ClerkExpressRequireAuth } from '@clerk/clerk-sdk-node';
app.get('/api/protected', ClerkExpressRequireAuth(), (req, res) => res.json({ ok: true }));

If using @clerk/express v2:

import { requireAuth } from '@clerk/express';
app.get('/api/protected', requireAuth(), (req, res) => res.json({ ok: true }));


	•	Ensure frontend attaches auth token on requests:
	•	If using Clerk’s withAuth fetch helper, confirm it’s wired.
	•	Otherwise, retrieve session token from Clerk client and set Authorization: Bearer <token>.

4) Replit/CORS/redirect correctness
	•	Confirm the live URL (not preview iframe). Echo it in logs.
	•	In code, set CORS to allow:

app.use(cors({
  origin: [process.env.APP_BASE_URL],
  credentials: true,
  methods: ['GET','POST','PUT','DELETE','OPTIONS'],
  allowedHeaders: ['Content-Type','Authorization']
}));


	•	Verify OAuth callback route (framework-specific). Common patterns:
	•	Next: /sso-callback
	•	SPA: Clerk handles, but Authorized Redirect URLs in Clerk must include APP_BASE_URL/*.
	•	Create /health/server route → returns { ok: true, time, envMode }.

5) Dashboard alignment (log-only checklist)

Programmatically print a checklist that the operator can confirm in Clerk dashboard:
	•	Settings → URLs → Allowed Origins (CORS) includes:
	•	https://*.replit.dev
	•	APP_BASE_URL
	•	Authorized Redirect URLs includes the app’s callback (e.g., APP_BASE_URL/sso-callback or main domain).
	•	Keys: publishable/secret both test or both live; frontendApi matches the selected environment.

6) Email/Password flow first
	•	Disable social temporarily in UI and verify:
	•	Sign-up → sign-in → access /api/protected (200).
	•	Sign-out → /api/protected returns 401.

7) Google OAuth
	•	Re-enable Google.
	•	Test full redirect flow in a fresh tab (not embedded). Confirm session initialized; /api/protected returns 200.

8) Add diagnostics endpoints
	•	/health/auth: server-side Clerk minimal call using CLERK_SECRET_KEY to validate key and instance reachability; return { ok: true, env: 'test|live' } or structured error.
	•	/debug/jwt (development only, behind NODE_ENV!=='production'): decode received Bearer token header and return claims minus sensitive fields.

9) Logs & error hardening
	•	Add structured logging around auth:
	•	Log origin, path, auth status (no tokens in logs).
	•	On 401, print which check failed (no header, bad signature, wrong audience, env mismatch).
	•	Ensure server time is good; print Date.now() and process.uptime() in /health/server.

10) Deliverables
	•	docs/AUTH_DIAGNOSIS.md: root cause(s) found, exact fixes applied, screenshots placeholders, post-fix test steps.
	•	docs/OPERATOR_CHECKLIST.md: dashboard settings and how to verify them on every deploy.
	•	docs/ROLLBACK.md: how to revert this branch cleanly.
	•	Commit minimal .env.example with placeholders for required keys.

TEST PLAN (run automatically)
	1.	Build & start app.
	2.	Hit /health/server → expect 200 { ok: true }.
	3.	Hit /health/auth (server-to-Clerk) → expect 200 { ok: true }.
	4.	From browser:
	•	Visit /sign-up → create user (email/pw).
	•	Visit protected route → expect 200.
	•	Sign out → protected route → expect 401.
	•	Initiate Google OAuth → sign in → protected route 200.
	5.	Console must show no Clerk 401 during normal flows.

PLAN B (only if ENABLE_PLAN_B=true)
	•	Create isolated branch auth/supabase-migration.
	•	Add Supabase Auth:
	•	Env: SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY.
	•	Frontend: use @supabase/supabase-js for email+Google.
	•	Backend: verify JWT with Supabase middleware; mirror users to local users table (auth_user_id, email, created_at).
	•	Maintain identical public API and protected route semantics.
	•	Update docs/AUTH_DIAGNOSIS.md with rationale for migration and parity tests.

OUTPUT
	•	Apply changes, run tests, and print a concise summary:
	•	Detected stack, issues found, fixes applied.
	•	Final URLs used (redacted).
	•	Exact Clerk dashboard fields the operator must verify.
	•	Next steps if any checks failed.
