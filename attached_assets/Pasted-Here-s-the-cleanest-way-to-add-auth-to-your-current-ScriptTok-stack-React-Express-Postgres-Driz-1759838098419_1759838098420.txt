Here’s the cleanest way to add auth to your current ScriptTok stack (React + Express + Postgres/Drizzle), without running into the iframe/third-party cookie issues you saw with Clerk in Replit. Repo structure + tech confirms you’ve got a single Node/Express server with a React client, Postgres via Drizzle, and Wouter/TanStack on the front end—perfect for a simple, first-party, cookie-based JWT flow.  ￼  ￼

Recommended UX flow
	1.	Landing page (public): “What it is” + CTA → “Start for free”.
	2.	Auth screen: Sign up / Log in (email + password to start; add Google later).
	3.	App area (private): /studio with your Viral & Affiliate tabs. Block API routes and pages unless authenticated.  ￼

Why this approach
	•	First-party cookies (httpOnly, same-site) avoid iframe/3rd-party cookie blockers.
	•	Keeps everything inside your existing stack—Express middleware + Drizzle users table.  ￼
	•	Easy to add roles/tiers later (free vs. paid) using a column on users and a gatekeeper middleware for “pro” endpoints.  ￼

Minimal logic map

Frontend
	•	AuthProvider (context) holds user and isAuthenticated, hydrated from /api/auth/me.
	•	Route guard (HOC or wrapper): if not authed → redirect to /login (or show modal).
	•	React Query mutations for login, register, logout.

Backend
	•	POST /api/auth/register → create user (bcrypt hash), set session cookie.
	•	POST /api/auth/login → verify, set cookie.
	•	POST /api/auth/logout → clear cookie.
	•	GET /api/auth/me → returns user profile if JWT valid.
	•	authRequired middleware protects: /api/generate-content*, /api/history, etc. (open only what must be public, like /health).  ￼

Tokens & cookies
	•	Sign a short-lived JWT (e.g., 15m) + rotate/refresh via a server-stored refresh token (or keep it simple: 7-day JWT and rotate on use).
	•	Store access token in an httpOnly, SameSite=Lax cookie; never in localStorage.

Data model (Drizzle)
	•	users table: id, email (unique), password_hash, name, plan (free|pro), created_at.
	•	Optional sessions table if you want refresh tokens or audit logs.

Environment
	•	Add AUTH_SECRET and AUTH_COOKIE_NAME to .env. You already centralize envs and run the server on port 3000.  ￼

Dev vs Prod
	•	NODE_ENV=development: allow “Skip login” toggle in the client that seeds a fake user context (but keep server routes protected so you don’t accidentally leak).
	•	NODE_ENV=production: disable skip, require auth everywhere beyond landing.
	•	Feature flag (e.g., VITE_ENABLE_PAYWALL=false in dev) to bypass any pro gates.  ￼

⸻

Drop-in Replit Agent prompt (paste as-is)

Goal: Add first-party, cookie-based email/password authentication to ScriptTok (monorepo: React client + Express server + Postgres/Drizzle). Create a public landing page → login/register → authenticated app flow. Do not require a Replit account to log in. Use httpOnly cookies; avoid third-party cookies.

Repo facts you should rely on:
	•	Tech: React 18 + TypeScript + Wouter routing, TanStack Query, Tailwind; Express + TypeScript; Postgres with Drizzle.
	•	Single unified server on port 3000; .env handling already exists.

Make these changes end-to-end:
	1.	Database (Drizzle)

	•	Add users table: id (uuid pk), email (text unique not null), passwordHash (text not null), name (text), plan (text default 'free'), createdAt (timestamp default now).
	•	Add a Drizzle migration and push it.

	2.	Server: /server

	•	Add lib/auth.ts: helpers hashPassword, verifyPassword (bcrypt), signJwt, verifyJwt (HS256, secret from AUTH_SECRET).
	•	Add middleware/authRequired.ts: verify JWT from cookie; attach req.user.
	•	Create routes under /api/auth:
	•	POST /register {email,password,name?} → create user, set cookie (httpOnly, SameSite=Lax, secure in prod), return minimal profile {id,email,name,plan}.
	•	POST /login {email,password} → verify, set cookie, return profile.
	•	POST /logout → clear cookie.
	•	GET /me → return profile if cookie valid.
	•	Protect existing private endpoints (/api/generate-content*, /api/history, /api/analytics/*) with authRequired. Leave /health public.
	•	Add envs: AUTH_SECRET, AUTH_COOKIE_NAME=st_sess, ensure CORS is configured for same-origin requests (client served by same Express instance).

	3.	Client: /client

	•	Pages: add /login and /register (shared form with React Hook Form + Zod).
	•	Add providers/AuthProvider.tsx:
	•	Holds user, isAuthenticated. On mount, call /api/auth/me to hydrate.
	•	Expose login, register, logout via React Query mutations.
	•	Add components/ProtectedRoute.tsx: if not authed, redirect to /login with redirectTo param; else render children.
	•	Routing:
	•	/ → new Landing component (public: hero, features, CTA → /login).
	•	/studio (and other app pages) → wrap with <ProtectedRoute>.
	•	UI polish: show user avatar/email + “Logout” in the top nav when authed.

	4.	Dev vs Prod behavior

	•	If import.meta.env.DEV, show a “Skip login (dev only)” button on /login that calls a client-side setDevUser() in AuthProvider (DO NOT bypass server middleware; this is client-only to speed UI work).
	•	Add VITE_ENABLE_PAYWALL=false in dev; true in prod (you will enforce plan checks in server middleware later).

	5.	Security & quality

	•	Use httpOnly cookies only; no tokens in localStorage.
	•	Rate-limit /api/auth/* endpoints.
	•	Validate inputs with Zod (email format, password length ≥ 8).
	•	Return consistent JSON error shapes.
	•	Add minimal tests: unit test for verifyPassword, integration test for /login happy path and 401 on a protected endpoint without cookie.

	6.	Files to create/modify (high level)

	•	shared/schema.ts → add users model.
	•	server/lib/auth.ts, server/middleware/authRequired.ts, server/api/auth/*.ts
	•	client/src/providers/AuthProvider.tsx
	•	client/src/pages/Login.tsx, client/src/pages/Register.tsx
	•	client/src/components/ProtectedRoute.tsx
	•	client/src/pages/Landing.tsx + wire / and /studio routes.

	7.	Run & verify

	•	npm run db:push then npm run dev.
	•	Manually test: register → redirected to /studio → refresh keeps session → logout clears session → visiting /studio after logout redirects to /login.
	•	Ensure protected API routes return 401 without cookie.

Deliverables: All code changes, plus a short README section titled “Authentication” with usage notes, env vars, and the route contract.

If you want Google sign-in later, have the agent add an /api/auth/oauth/google route using passport-google-oauth20 that still ends by minting your own first-party session cookie (so it stays Replit-safe).

Want me to tailor the landing wireframe copy + the exact login/registration UI (fields, validation messages, and redirects) to your ScriptTok voice?