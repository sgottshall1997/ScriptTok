and safe dev bypasses for the ScriptTok application.

Core Requirements
1. Environment Configuration
Create environment variables and respect them throughout the entire codebase:

Required Environment Variables:

APP_ENV = "development" | "production"
APP_URL (per environment)
VITE_API_BASE_URL (frontend API base)
BYPASS_LIMITS = "1" in dev, "0" in prod
DISABLE_BILLING = "1" in dev, "0" in prod
DEV_USER_ID (UUID, used only in dev)
DEV_USER_EMAIL (used only in dev)
DATABASE_URL (separate dev and prod databases)
For Production Auth (Supabase):

SUPABASE_JWT_SECRET
VITE_SUPABASE_URL
VITE_SUPABASE_ANON_KEY
For Billing (Stripe):

STRIPE_SECRET_KEY
STRIPE_WEBHOOK_SECRET
Add all these to .env.example with clear documentation.

2. Authentication Adapter Pattern
Create server/auth/adapters.ts with:

export type AuthResult = { 
  userId: string; 
  email?: string; 
  tierHint?: 'pro' | 'free' 
};
export type VerifyFn = (authHeader?: string) => Promise<AuthResult | null>;
Dev Adapter (verifyDev):

Returns fixed user from DEV_USER_ID and DEV_USER_EMAIL
Always returns tierHint: 'pro'
No external service calls
No cookies or redirects
Prod Adapter (verifySupabase):

Verifies Bearer JWT tokens
Returns { userId: sub, email } from JWT
Handles token expiry and validation errors
Switcher Logic:

export const verifyAuth: VerifyFn = 
  process.env.APP_ENV === 'production' ? verifySupabase : verifyDev;
3. Auth Guard Middleware
Create server/middleware/authGuard.ts:

Production behavior:

Require Bearer token in Authorization header
Call verifyAuth()
Return 401 on failure
Development behavior:

If verifyAuth() fails, inject dev user automatically
Never block requests in dev mode
Log all auth attempts for debugging
Apply this middleware to all protected routes (content generation, history, etc.)

4. Database Schema Updates
Update shared/schema.ts with identity mapping tables:

users table (already exists, but ensure):

id UUID primary key
email TEXT
created_at TIMESTAMPTZ
user_identities table (NEW):

id UUID primary key
user_id UUID foreign key to users(id)
provider TEXT (e.g., "supabase", "dev")
provider_user_id TEXT
email_at_signup TEXT
UNIQUE constraint on (provider, provider_user_id)
subscriptions table (NEW):

user_id UUID primary key foreign key to users(id)
tier TEXT default 'free'
status TEXT default 'active'
start_at TIMESTAMPTZ
end_at TIMESTAMPTZ
monthly_usage table (NEW):

user_id UUID
period_yyyymm CHAR(7) (e.g., "2025-01")
generations_used INT default 0
PRIMARY KEY (user_id, period_yyyymm)
Create migration file in migrations/ folder.

5. Identity Linkage Service
Create server/services/identityService.ts:

Core Functions:

findOrCreateUser(provider, providerUserId, email) - maps provider IDs to internal user IDs
linkIdentity(userId, provider, providerUserId) - creates user_identity record
getUserByIdentity(provider, providerUserId) - lookup by provider ID
On Every Authenticated Request:

Extract auth result from verifyAuth()
Find or create user via user_identities mapping
Store provider mapping if new
Return internal users.id for all business logic
Never use provider IDs for data storage - always use users.id.

6. Entitlements & Usage Tracking
Create server/services/quotaService.ts:

Helper Functions:

currentPeriod() → returns 'YYYY-MM'
getOrCreateMonthlyUsage(userId) - finds or creates usage record
incrementUsage(userId, count) - atomic increment
getUserTier(userId) - gets tier from subscriptions table
getTierLimit(tier) - returns limit (free: 10, pro: 500)
Quota Middleware (server/middleware/checkQuota.ts):

Skip all checks if BYPASS_LIMITS === '1'
Otherwise:
Get user tier from subscriptions
Get current month usage
Check against tier limits
Return 429 if exceeded with upgrade message
Increment usage on success
7. Content Generation Updates
Update server/api/generateContent.ts:

Add authGuard middleware before handler
Add checkQuota middleware before generation
Extract userId from req.user (set by authGuard)
Pass userId to storage methods
Link all generated content to users.id (not provider IDs)
8. Frontend Auth Integration
Create client/src/lib/auth.ts:

Dev Mode:

Auto-inject dev user token
No login UI
Show dev mode banner
Prod Mode:

Supabase auth client setup
Login/signup forms
Token refresh logic
Logout functionality
Create client/src/components/AuthProvider.tsx:

Wraps app with auth context
Provides user, login(), logout(), signup()
Handles token storage
9. Billing Integration (Prod Only)
Create server/api/billing.ts:

If DISABLE_BILLING === '1':

All upgrade requests instantly succeed
Mock subscription created in database
Return success without Stripe
If production with billing enabled:

Stripe checkout session creation
Webhook handler for subscription events
Update subscriptions table on payment
Handle cancellations and renewals
10. API Route Protection
Update server/routes.ts:

Public Routes (no auth):

/api/trends (public trending data)
/api/health (health check)
Landing page routes
Protected Routes (require auth):

/api/generate-content - auth + quota check
/api/history - auth required
/api/perplexity-trends - auth required
All user-specific endpoints
Apply middleware in this order: authGuard → checkQuota → route handler

11. Testing & Validation
Create test utilities in server/utils/testAuth.ts:

createTestUser() - creates dev user
generateDevToken() - creates dev mode token
validateQuotaEnforcement() - tests limits
Add environment-specific logging:

Dev: verbose auth/quota logs
Prod: security-focused minimal logs
12. Documentation
Update README.md with:

Development Setup:

Set APP_ENV=development
Configure DEV_USER_ID and DEV_USER_EMAIL
All auth bypassed automatically
Unlimited quotas
Production Deployment:

Set APP_ENV=production
Configure Supabase credentials
Set up Stripe (or disable billing)
Auth required for all protected routes
Quota enforcement active
Environment Switching:

Clear instructions for toggling environments
Migration path from dev to prod
Rollback procedures
Success Criteria
When complete, the system should:

✅ Work in dev without any login (auto-inject dev user)
✅ Work in prod with real Supabase authentication
✅ Never store data under provider IDs (always use users.id)
✅ Enforce quotas in prod, bypass in dev
✅ Support swapping auth providers without touching business logic
✅ Have clear tier-based entitlements (free: 10/mo, pro: 500/mo)
✅ Disable billing in dev, enable in prod
✅ Provide comprehensive logging for debugging
✅ Include proper error handling and user feedback

Implementation Order
Environment variables and configuration
Database schema and migrations
Auth adapters and middleware
Identity linkage service
Quota/usage tracking service
Update existing API routes with auth
Frontend auth integration
Billing integration (if enabled)
Testing and validation
Documentation
Build this entire system now, ensuring all files are created, all existing routes are updated with auth, and the system works seamlessly in both development and production environments.