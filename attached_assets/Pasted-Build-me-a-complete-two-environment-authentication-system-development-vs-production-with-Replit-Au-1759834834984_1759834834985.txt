Build me a complete two-environment authentication system (development vs production) with Replit Auth, tiered entitlements, and safe dev bypasses for the ScriptTok application.

Core Requirements
1. Environment Configuration
Create environment variables and respect them throughout the entire codebase:

Required Environment Variables:

APP_ENV = "development" | "production"
APP_URL (per environment)
VITE_API_BASE_URL (frontend API base)
BYPASS_LIMITS = "1" in dev, "0" in prod
DISABLE_BILLING = "1" in dev, "0" in prod
DEV_USER_ID (UUID, used only in dev)
DEV_USER_EMAIL (used only in dev)
DATABASE_URL (separate dev and prod databases)
For Billing (Stripe):

STRIPE_SECRET_KEY
STRIPE_WEBHOOK_SECRET
Add all these to .env.example with clear documentation.

2. Authentication Adapter Pattern
Create server/auth/adapters.ts with:

export type AuthResult = { 
  userId: string; 
  email?: string; 
  name?: string;
  profileImage?: string;
  tierHint?: 'pro' | 'free' 
};
export type VerifyFn = (req: any) => Promise<AuthResult | null>;
Dev Adapter (verifyDev):

Returns fixed user from DEV_USER_ID and DEV_USER_EMAIL
Always returns tierHint: 'pro'
No external service calls
No cookies or redirects
Prod Adapter (verifyReplitAuth):

Reads Replit Auth headers from request:
X-Replit-User-Id
X-Replit-User-Name
X-Replit-User-Email
X-Replit-User-Profile-Image
Returns { userId, email, name, profileImage } from headers
Handles missing headers as unauthorized
Switcher Logic:

export const verifyAuth: VerifyFn = 
  process.env.APP_ENV === 'production' ? verifyReplitAuth : verifyDev;
3. Auth Guard Middleware
Create server/middleware/authGuard.ts:

Production behavior:

Check for Replit Auth headers
Call verifyAuth(req)
Return 401 if no valid user found
Set req.user with auth result
Development behavior:

If verifyAuth() fails, inject dev user automatically
Never block requests in dev mode
Log all auth attempts for debugging
Always set req.user with dev user
Apply this middleware to all protected routes (content generation, history, etc.)

4. Database Schema Updates
Update shared/schema.ts with identity mapping tables:

users table (already exists, but ensure):

id UUID primary key
email TEXT
name TEXT
profile_image TEXT
created_at TIMESTAMPTZ
user_identities table (NEW):

id UUID primary key
user_id UUID foreign key to users(id)
provider TEXT (e.g., "replit", "dev")
provider_user_id TEXT
email_at_signup TEXT
UNIQUE constraint on (provider, provider_user_id)
subscriptions table (NEW):

user_id UUID primary key foreign key to users(id)
tier TEXT default 'free'
status TEXT default 'active'
start_at TIMESTAMPTZ
end_at TIMESTAMPTZ
monthly_usage table (NEW):

user_id UUID
period_yyyymm CHAR(7) (e.g., "2025-01")
generations_used INT default 0
PRIMARY KEY (user_id, period_yyyymm)
Create migration file in migrations/ folder.

5. Identity Linkage Service
Create server/services/identityService.ts:

Core Functions:

findOrCreateUser(provider, providerUserId, email, name?, profileImage?) - maps provider IDs to internal user IDs
linkIdentity(userId, provider, providerUserId) - creates user_identity record
getUserByIdentity(provider, providerUserId) - lookup by provider ID
On Every Authenticated Request:

Extract auth result from verifyAuth()
Find or create user via user_identities mapping
Store provider mapping if new
Return internal users.id for all business logic
Never use provider IDs for data storage - always use users.id.

6. Entitlements & Usage Tracking
Create server/services/quotaService.ts:

Helper Functions:

currentPeriod() → returns 'YYYY-MM'
getOrCreateMonthlyUsage(userId) - finds or creates usage record
incrementUsage(userId, count) - atomic increment
getUserTier(userId) - gets tier from subscriptions table
getTierLimit(tier) - returns limit (free: 10, pro: 500)
Quota Middleware (server/middleware/checkQuota.ts):

Skip all checks if BYPASS_LIMITS === '1'
Otherwise:
Get user tier from subscriptions
Get current month usage
Check against tier limits
Return 429 if exceeded with upgrade message
Increment usage on success
7. Content Generation Updates
Update server/api/generateContent.ts:

Add authGuard middleware before handler
Add checkQuota middleware before generation
Extract userId from req.user (set by authGuard)
Pass userId to storage methods
Link all generated content to users.id (not provider IDs)
8. Frontend Auth Integration
Create client/src/lib/auth.ts:

Dev Mode:

Auto-inject dev user token
No login UI needed
Show dev mode banner
Prod Mode:

Use Replit Auth button: <script authed src="https://auth.replit.com/authenticate.js"></script>
Check authentication status via /__replauthuser endpoint
Display user info from Replit Auth
Logout via Replit's built-in logout
Create client/src/components/AuthProvider.tsx:

Wraps app with auth context
Provides user, login(), logout(), isAuthenticated()
Handles Replit Auth integration
Shows login button when unauthenticated in production
9. Replit Auth Login Page Setup
For Production:

Enable Replit Auth in the workspace tool
Use the prebuilt login page OR
Use custom button with this script in your HTML:
<script authed src="https://auth.replit.com/authenticate.js"></script>
<button onclick="LoginWithReplit()">Log in with Replit</button>
Authentication Flow:

Users click login button
Replit handles OAuth (Google, Email, etc.)
After auth, Replit sets headers on all requests
Backend reads headers to identify user
10. Billing Integration (Prod Only)
Create server/api/billing.ts:

If DISABLE_BILLING === '1':

All upgrade requests instantly succeed
Mock subscription created in database
Return success without Stripe
If production with billing enabled:

Stripe checkout session creation
Webhook handler for subscription events
Update subscriptions table on payment
Handle cancellations and renewals
11. API Route Protection
Update server/routes.ts:

Public Routes (no auth):

/api/trends (public trending data)
/api/health (health check)
Landing page routes
Protected Routes (require auth):

/api/generate-content - auth + quota check
/api/history - auth required
/api/perplexity-trends - auth required
All user-specific endpoints
Apply middleware in this order: authGuard → checkQuota → route handler

12. Testing & Validation
Create test utilities in server/utils/testAuth.ts:

createTestUser() - creates dev user
generateDevToken() - creates dev mode token
validateQuotaEnforcement() - tests limits
Add environment-specific logging:

Dev: verbose auth/quota logs
Prod: security-focused minimal logs
13. Documentation
Update README.md with:

Development Setup:

Set APP_ENV=development
Configure DEV_USER_ID and DEV_USER_EMAIL
All auth bypassed automatically
Unlimited quotas
Production Deployment:

Set APP_ENV=production
Enable Replit Auth in workspace (one-click setup)
Set up Stripe (or disable billing)
Auth required for all protected routes
Quota enforcement active
Replit Auth Features:

Users can sign up with email or Google
No external auth service setup needed
Automatic user session management
Built-in logout functionality
Environment Switching:

Clear instructions for toggling environments
Migration path from dev to prod
Rollback procedures
Success Criteria
When complete, the system should:

✅ Work in dev without any login (auto-inject dev user)
✅ Work in prod with Replit Auth (email/Google signup)
✅ Never store data under provider IDs (always use users.id)
✅ Enforce quotas in prod, bypass in dev
✅ Support swapping auth providers without touching business logic
✅ Have clear tier-based entitlements (free: 10/mo, pro: 500/mo)
✅ Disable billing in dev, enable in prod
✅ Provide comprehensive logging for debugging
✅ Include proper error handling and user feedback
✅ Use Replit's built-in auth headers for user identification

Implementation Order
Environment variables and configuration
Database schema and migrations
Auth adapters and middleware (Replit Auth headers)
Identity linkage service
Quota/usage tracking service
Update existing API routes with auth
Frontend auth integration (Replit Auth button)
Billing integration (if enabled)
Testing and validation
Documentation
Build this entire system now, ensuring all files are created, all existing routes are updated with auth, and the system works seamlessly in both development and production environments using Replit Auth.