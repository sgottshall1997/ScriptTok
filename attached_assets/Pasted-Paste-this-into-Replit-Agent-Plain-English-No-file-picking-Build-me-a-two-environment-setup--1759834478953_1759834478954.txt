Paste this into Replit Agent. Plain English. No file picking.

⸻

Build me a two-environment setup (development vs production) with provider-agnostic auth, tiered entitlements, and safe dev bypasses.

Goals
	•	Single codebase that runs in development without login, quotas, or billing; and in production with real auth, quotas, and billing.
	•	Auth is adapter-based so I can swap providers later without touching business logic.
	•	Entitlements (free vs premium) are provider-agnostic and keyed to my own users.id.

Environment matrix

Implement env flags and respect them everywhere:
	•	APP_ENV = development | production
	•	APP_URL (per env)
	•	VITE_API_BASE_URL (front-end)
	•	BYPASS_LIMITS (1 in dev; 0 in prod)
	•	DISABLE_BILLING (1 in dev; 0 in prod)
	•	DEV_USER_ID, DEV_USER_EMAIL (used only in dev)
	•	DATABASE_URL (dev DB vs prod DB)
	•	If using a managed auth in prod (e.g., Supabase): SUPABASE_JWT_SECRET, VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY
	•	For Stripe in prod: STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET (test keys in dev or disable)

Auth (adapter pattern)

Create a minimal, swappable interface and two adapters.
	•	Interface:

export type AuthResult = { userId: string; email?: string; tierHint?: 'pro'|'free' };
export type VerifyFn = (authHeader?: string) => Promise<AuthResult|null>;


	•	Dev adapter (verifyDev): returns a fixed user (from DEV_USER_ID, DEV_USER_EMAIL) and tierHint:'pro'. No external service. No cookies. No redirects.
	•	Prod adapter (verifySupabase for example): verify Bearer JWT, return { userId: sub, email }.
	•	Switcher:

export const verifyAuth: VerifyFn =
  process.env.APP_ENV === 'production' ? verifySupabase : verifyDev;


	•	authGuard middleware:
	•	In prod: require Bearer token → verifyAuth → 401 on failure.
	•	In dev: if verifyAuth fails, inject the dev user instead.

Identity + linkage

Schema (SQL or Prisma), keyed to my own IDs:
	•	users(id UUID PK, email TEXT, created_at TIMESTAMPTZ)
	•	user_identities(id UUID PK, user_id UUID FK, provider TEXT, provider_user_id TEXT, email_at_signup TEXT, UNIQUE(provider, provider_user_id))

On every authenticated request:
	•	Find or create users by mapping (provider, provider_user_id) via user_identities.
	•	Never store business data under provider IDs; always use users.id.

Entitlements + usage

Provider-agnostic tables:
	•	subscriptions(user_id PK, tier TEXT DEFAULT 'free', status TEXT DEFAULT 'active', start_at, end_at)
	•	monthly_usage(user_id, period_yyyymm CHAR(7), generations_used INT DEFAULT 0, PRIMARY KEY(user_id, period_yyyymm))

Helpers:
	•	currentPeriod() → 'YYYY-MM'
	•	getOrCreateMonthlyUsage(userId)
	•	incrementUsage(userId, 1)

Quota middleware

checkGenerationQuota:
	•	If APP_ENV !== 'production' and BYPASS_LIMITS==='1' → skip checks.
	•	Else load user’s tier and effective limit:
	•	Defaults: free=10/month, pro=500/month (constants; overridable by a tier_limits table).
	•	If used ≥ limit → 429 { code:'generation_quota_exceeded', used, limit, period }.
	•	On success, the handler increments generations_used atomically.

Billing guard

Routes that upgrade a user:
	•	If DISABLE_BILLING==='1' → set tier=pro directly (dev shortcut), return {ok:true, mode:'dev-upgrade'}.
	•	Else run Stripe flow (checkout/webhook) in prod.

Public vs protected APIs
	•	Public: GET /api/trends?niche=... (returns latest cached row via ORDER BY fetched_at DESC LIMIT 1; no CURRENT_DATE equality).
	•	Protected: POST /api/generate (authGuard + checkGenerationQuota).

Daily trends job (worker or route)
	•	A scheduled script (separate “worker” entry point or protected internal route) that:
	•	Iterates niches array (configurable via env).
	•	Fetches Perplexity once per niche per day.
	•	Upserts (niche, date) with data JSONB, fetched_at TIMESTAMPTZ.
	•	Logs one line per niche. No file writes; stdout only.

Healthchecks + logging
	•	GET /health/server → 200
	•	GET /health/db → 200
	•	All logging to stdout (remove file logger/ENOENT risks). Include env, userId (hashed), route, status.

Front-end behavior (Vite)
	•	Read VITE_API_BASE_URL and always send Authorization: Bearer <token> in prod.
	•	In dev: the token can be omitted; server will inject dev user.
	•	Basic dashboard showing: email, tier, and “X/Y generations used this month”.

Non-goals (for this task)
	•	No admin panel.
	•	No multi-tenant teams.
	•	No advanced billing proration.

Acceptance criteria
	•	With APP_ENV=development, BYPASS_LIMITS=1, DISABLE_BILLING=1:
	•	App loads without any login UI.
	•	GET /api/trends?niche=skincare returns cached JSON (or empty structure if seed not run).
	•	POST /api/generate succeeds and does not enforce quotas or billing.
	•	With APP_ENV=production, BYPASS_LIMITS=0, DISABLE_BILLING=0 and a valid Bearer token:
	•	POST /api/generate enforces tier limits and increments usage; returns 429 at cap.
	•	Upgrading (via real billing path) flips tier to pro; subsequent requests use higher limits.
	•	Healthchecks return 200; logs show one daily fetch per niche.

Implement all of the above, wire envs, and add a short README noting which variables to set for dev vs prod.